// RobotBuilder Version: 4.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: Subsystem.

package frc.robot.subsystems;


import com.ctre.phoenix.motorcontrol.ControlMode;
import com.ctre.phoenix.motorcontrol.DemandType;
import com.ctre.phoenix.motorcontrol.FeedbackDevice;
import com.ctre.phoenix.motorcontrol.FollowerType;
import com.ctre.phoenix.motorcontrol.InvertType;
import com.ctre.phoenix.motorcontrol.NeutralMode;
import com.ctre.phoenix.motorcontrol.RemoteSensorSource;
import com.ctre.phoenix.motorcontrol.StatusFrame;
import com.ctre.phoenix.motorcontrol.SupplyCurrentLimitConfiguration;
import com.ctre.phoenix.motorcontrol.TalonFXInvertType;
import com.ctre.phoenix.motorcontrol.can.TalonFXConfiguration;
import com.ctre.phoenix.motorcontrol.can.TalonSRXConfiguration;
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS
import com.ctre.phoenix.motorcontrol.can.WPI_TalonFX;
import com.ctre.phoenix.sensors.PigeonIMU;
import com.ctre.phoenix.sensors.PigeonIMU_StatusFrame;

import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj.drive.DifferentialDrive;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;
import edu.wpi.first.wpilibj2.command.SubsystemBase;
import frc.robot.Constants;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=IMPORTS


/**
 *
 */
public class Drive extends SubsystemBase {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
private WPI_TalonFX leftMaster;
private WPI_TalonFX rightMaster;
private DifferentialDrive differentialDrive;
private PigeonIMU pigeon;
private WPI_TalonFX rightFollower;
private WPI_TalonFX leftFollower;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
double y;
double twist;

TalonFXInvertType _rightInvert = TalonFXInvertType.CounterClockwise; // Same as invert = "false"
TalonFXInvertType _leftInvert = TalonFXInvertType.Clockwise; // Same as invert = "true"
TalonFXConfiguration _rightConfig = new TalonFXConfiguration();
TalonFXConfiguration _leftConfig = new TalonFXConfiguration();
    /**
    *
    */
    public Drive() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
leftMaster = new WPI_TalonFX(3);
 
 

rightMaster = new WPI_TalonFX(1);
 
 

differentialDrive = new DifferentialDrive(leftMaster, rightMaster);
 addChild("differentialDrive",differentialDrive);
 differentialDrive.setSafetyEnabled(true);
differentialDrive.setExpiration(0.1);
differentialDrive.setMaxOutput(1.0);


pigeon = new PigeonIMU(4);
 
 

rightFollower = new WPI_TalonFX(0);
 
 

leftFollower = new WPI_TalonFX(2);
 
 


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
    rightMaster.setInverted(InvertType.InvertMotorOutput);
        motorConfigFalcon();
    }

    @Override
    public void periodic() {
        // This method will be called once per scheduler run

    }

    @Override
    public void simulationPeriodic() {
        // This method will be called once per scheduler run when in simulation

    }

    // Put methods for controlling this subsystem
    // here. Call these from Commands.
public void JoystickDrive(Joystick joystickP0) {
    y = joystickP0.getY();
    twist = joystickP0.getZ();
  //  DifferentialDrive.arcadeDriveIK(Math.pow(y, 5), Math.pow(twist, 5), false);
    differentialDrive.arcadeDrive(Math.pow(y, 5),-Math.pow(twist, 5));
}
    public void driveFroward(){
        differentialDrive.arcadeDrive(0.3 ,0);


    }

    public void turnLeft(){
        differentialDrive.arcadeDrive(0, 0.5);
    }

    public void turnRight(){
        differentialDrive.arcadeDrive(0, -0.5);
    }

    public boolean turnComplete(double target){
        double[] ypr = new double[3];
        pigeon.getYawPitchRoll(ypr);
        return Math.abs(ypr[0] - target) < (360 * 0.005);
    }

    public void angleTurn(double angle){
        rightMaster.set(ControlMode.MotionMagic, 0, DemandType.AuxPID, angle*10);
        leftMaster.follow(rightMaster, FollowerType.AuxOutput1);


    }

    public void stop(){
        rightMaster.set(0.0);
        leftMaster.set(0.0);
    }
       
public void motorConfigFalcon() {
    // Factory default all motors initially
    rightMaster.configFactoryDefault();
    rightFollower.configFactoryDefault();
    leftMaster.configFactoryDefault();
    leftFollower.configFactoryDefault();

    // Set Neutral Mode
    leftMaster.setNeutralMode(NeutralMode.Brake);
    leftFollower.setNeutralMode(NeutralMode.Brake);
    rightMaster.setNeutralMode(NeutralMode.Brake);
    rightFollower.setNeutralMode(NeutralMode.Brake);

    // Configure output and sensor direction
    leftMaster.setInverted(_leftInvert);
    leftFollower.setInverted(_leftInvert);
    rightMaster.setInverted(_rightInvert);
    rightFollower.setInverted(_rightInvert);

    // configure the max current for motor. Thought is that
    // other motors will follow.
    double ampLimit = SmartDashboard.getNumber("test/drive/Amp Limit", 40);
    double ampPeakLimit = SmartDashboard.getNumber("test/drive/Amp/peak Limit", 60);

    SupplyCurrentLimitConfiguration currentLimitingFalcons = new SupplyCurrentLimitConfiguration(
            true, ampLimit, ampPeakLimit, 0);

    rightMaster.configSupplyCurrentLimit(currentLimitingFalcons);

    // Reset Pigeon Configs
    pigeon.configFactoryDefault();

    _leftConfig.primaryPID.selectedFeedbackSensor = FeedbackDevice.IntegratedSensor; // Local Feedback Source

    // * Configure the Remote (Left) Talon's selected sensor as a remote sensor for
    // * the right Talon

    _rightConfig.remoteFilter0.remoteSensorDeviceID = leftMaster.getDeviceID(); // Device ID of Remote Source
    _rightConfig.remoteFilter0.remoteSensorSource = RemoteSensorSource.TalonSRX_SelectedSensor; // Remote Source
                                                                                                // Type

    // * Now that the Left sensor can be used by the master Talon, set up the Left
    // * (Aux) and Right (Master) distance into a single Robot distance as the
    // * Master's Selected Sensor 0.

    setRobotDistanceConfigs(_rightInvert, _rightConfig);
    // FPID for Distance
    _rightConfig.slot0.kF = 0.1;
    _rightConfig.slot0.kP = 0;
    _rightConfig.slot0.kI = 0;
    _rightConfig.slot0.kD = 0;
    _rightConfig.slot0.integralZone = 100;
    _rightConfig.slot0.closedLoopPeakOutput = 0.50;

    // * Heading Configs
    _rightConfig.remoteFilter1.remoteSensorDeviceID = pigeon.getDeviceID(); // Pigeon Device ID
    _rightConfig.remoteFilter1.remoteSensorSource = RemoteSensorSource.Pigeon_Yaw; // This is for a Pigeon over CAN
    _rightConfig.auxiliaryPID.selectedFeedbackSensor = FeedbackDevice.RemoteSensor1; // Set as the Aux Sensor
    _rightConfig.auxiliaryPID.selectedFeedbackCoefficient = 3600.0 / 8192; // Convert
                                                                                                        // Yaw to
                                                                                                        // tenths of
                                                                                                        // a degree

    // * false means talon's local output is PID0 + PID1, and other side Talon is
    // PID0
    // * - PID1 This is typical when the master is the right Talon FX and using
    // Pigeon
    // *
    // * true means talon's local output is PID0 - PID1, and other side Talon is
    // PID0
    // * + PID1 This is typical when the master is the left Talon FX and using
    // Pigeon

    _rightConfig.auxPIDPolarity = false;
    // FPID for Heading
    _rightConfig.slot1.kF = 2.0;
    _rightConfig.slot1.kP = 0.0;
    _rightConfig.slot1.kI = 4.0;
    _rightConfig.slot1.kD = .0;
    _rightConfig.slot1.integralZone = 200;
    _rightConfig.slot1.closedLoopPeakOutput = 0.6;

    // Config the neutral deadband.
    _leftConfig.neutralDeadband = 0.001;
    _rightConfig.neutralDeadband = 0.001;

    // *
    // * 1ms per loop. PID loop can be slowed down if need be. For example, - if
    // * sensor updates are too slow - sensor deltas are very small per update, so
    // * derivative error never gets large enough to be useful. - sensor movement is
    // * very slow causing the derivative error to be near zero.

    int closedLoopTimeMs = 1;
    rightMaster.configClosedLoopPeriod(0, closedLoopTimeMs, 30);
    rightMaster.configClosedLoopPeriod(1, closedLoopTimeMs, 30);

    // Motion Magic Configs
    _rightConfig.motionAcceleration = 9500; // (distance units per 100 ms) per second
    _rightConfig.motionCruiseVelocity = 17000; // distance units per 100 ms

    // APPLY the config settings
    leftMaster.configAllSettings(_leftConfig);
    leftFollower.configAllSettings(_leftConfig);
    rightMaster.configAllSettings(_rightConfig);
    rightFollower.configAllSettings(_rightConfig);

    // Set status frame periods to ensure we don't have stale data

    // * These aren't configs (they're not persistant) so we can set these after the
    // * configs.

    rightMaster.setStatusFramePeriod(StatusFrame.Status_12_Feedback1, 20, 30);
    rightMaster.setStatusFramePeriod(StatusFrame.Status_13_Base_PIDF0, 20, 30);
    rightMaster.setStatusFramePeriod(StatusFrame.Status_14_Turn_PIDF1, 20, 30);
    rightMaster.setStatusFramePeriod(StatusFrame.Status_10_Targets, 10, 30);
    leftMaster.setStatusFramePeriod(StatusFrame.Status_2_Feedback0, 5, 30);
    pigeon.setStatusFramePeriod(PigeonIMU_StatusFrame.CondStatus_9_SixDeg_YPR, 5, 30);

    rightFollower.follow(rightMaster);
    leftFollower.follow(leftMaster);
    // WPI drivetrain classes assume by default left & right are opposite
    // - call this to apply + to both sides when moving forward


    // set on call from autonomous
    rightMaster.selectProfileSlot(0, 0);
    rightMaster.selectProfileSlot(1, 1);

}

void setRobotDistanceConfigs(TalonFXInvertType masterInvertType, TalonFXConfiguration masterConfiguration){
    if (masterInvertType == TalonFXInvertType.Clockwise){
        masterConfiguration.diff0Term = FeedbackDevice.IntegratedSensor;
        masterConfiguration.diff1Term = FeedbackDevice.RemoteSensor0;
        masterConfiguration.primaryPID.selectedFeedbackSensor = FeedbackDevice.SensorDifference;
    } else {
        masterConfiguration.sum0Term = FeedbackDevice.RemoteSensor0;
        masterConfiguration.sum1Term = FeedbackDevice.IntegratedSensor;
        masterConfiguration.primaryPID.selectedFeedbackSensor = FeedbackDevice.SensorSum;
    }
    masterConfiguration.primaryPID.selectedFeedbackCoefficient = 0.5;
}

public void zeroSensors(){
    leftMaster.getSensorCollection().setIntegratedSensorPosition(0, 30);
    rightMaster.getSensorCollection().setIntegratedSensorPosition(0, 30);

}
}

